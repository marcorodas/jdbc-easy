package pe.mrodas.jdbc;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

import pe.mrodas.jdbc.helper.Autoclose;
import pe.mrodas.jdbc.helper.Parameter;
import pe.mrodas.jdbc.helper.SqlDML;
import pe.mrodas.jdbc.helper.TableIterator;

public class SqlInsert implements SqlDML {

    private final static String QUERY = "INSERT INTO <table> (<fields>) VALUES (<values>)";
    private final Map<String, List<Object>> valueListMap = new HashMap<>();
    private final String table;
    private final Consumer<Integer> setterId;
    private String error;

    public SqlInsert(String table) {
        this(table, null);
    }

    public SqlInsert(String table, Consumer<Integer> setterId) {
        this.table = table.replace(" ", "");
        this.setterId = setterId;
    }

    @Override
    public SqlInsert addField(String name, Object value) {
        if (error != null) return this;
        if (name == null || name.trim().isEmpty())
            error = "Field name can't be null or empty!";
        else if (value != null) {
            if (!valueListMap.containsKey(name)) valueListMap.put(name, new ArrayList<>());
            valueListMap.get(name).add(value);
        }
        return this;
    }

    private int checkNumRows(List<String> fieldNames) throws IOException {
        List<Integer> rows = new ArrayList<>(1);
        for (String name : fieldNames) {
            int listSize = valueListMap.get(name).size();
            if (rows.isEmpty()) rows.add(listSize);
            else if (rows.get(0) != listSize) {
                String msg = listSize > rows.get(0) ? "more" : "less";
                throw new IOException(String.format("Fields Error: %s has %s rows than other fields!", name, msg));
            }
        }
        return valueListMap.get(fieldNames.get(0)).size();
    }

    private String getPreparedQuery(List<String> fieldNames) {
        int valuesSize = valueListMap.keySet().size();
        return QUERY.replace("<table>", table)
                .replace("<fields>", String.join(", ", fieldNames))
                .replace("<values>", String.join(", ", Collections.nCopies(valuesSize, "?")));
    }

    private PreparedStatement getPreparedStatement(Connection conn, String preparedQuery) throws SQLException {
        return this.setterId == null
                ? conn.prepareStatement(preparedQuery)
                : conn.prepareStatement(preparedQuery, Statement.RETURN_GENERATED_KEYS);
    }

    public void executeStatement(PreparedStatement statement, List<String> fieldNames, int totalRows) throws SQLException {
        int totalCols = fieldNames.size();
        TableIterator iterator = new TableIterator(totalRows, totalCols);
        try {
            for (Integer row : iterator.getRowIterator()) {
                for (Integer col : iterator.getColIterator().reset()) {
                    String name = fieldNames.get(col);
                    new Parameter<>(valueListMap.get(name).get(row))
                            .registerIN(statement, col + 1);
                }
                if (totalRows > 1) statement.addBatch();
            }
        } catch (SQLException e) {
            if (!iterator.getColIterator().hasNext()) throw e;
            String name = fieldNames.get(iterator.getPosCol());
            String errorMsg = "Insert into %s: Error setting '%s' parameter (row=%s) in statement! - %s";
            String error = String.format(errorMsg, this.table, name, iterator.getPosRow(), e.getMessage());
            throw new SQLException(error, e);
        }
        if (totalRows > 1) statement.executeBatch();
        else statement.execute();
    }

    public int execute() throws IOException, SQLException {
        return this.execute(null, null);
    }

    public int execute(Connection connection, Autoclose autoclose) throws IOException, SQLException {
        if (table == null) throw new IOException("Table name can't be null!");
        if (valueListMap.isEmpty()) error = "Fields can't be empty!";
        if (error != null) throw new IOException(error);
        List<String> fieldNames = new ArrayList<>(valueListMap.keySet());
        int totalRows = this.checkNumRows(fieldNames);
        Connection conn = connection == null ? Connector.getConnection() : connection;
        String preparedQuery = this.getPreparedQuery(fieldNames);
        PreparedStatement statement = this.getPreparedStatement(conn, preparedQuery);
        this.executeStatement(statement, fieldNames, totalRows);
        try {
            if (setterId == null) return statement.getUpdateCount();
            ResultSet rs = statement.getGeneratedKeys();
            if (rs.next()) {
                int autoGeneratedKey = rs.getInt(1);
                setterId.accept(autoGeneratedKey);
                if (autoGeneratedKey > 0) return autoGeneratedKey;
            }
            throw new SQLException("Error getting autogenerated key!");
        } finally {
            this.close(conn, autoclose == null ? Autoclose.YES : autoclose);
        }
    }

    private void close(Connection conn, Autoclose autoclose) {
        if (autoclose == Autoclose.YES) try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
